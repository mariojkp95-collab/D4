<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Drakoria ‚Äî D3-HUD1-root</title>
<style>
:root{
  --bg:#0b1224; --panel:#0f172a; --stroke:#1f2a44; --text:#e5e7eb; --muted:#9ca3af;
  --tileA:#0e2a1e; --tileB:#123022; --block:#15223b;
  --player:#3b82f6; --enemy:#ef4444; --coin:#facc15; --shadow:#0006; --hp:#10b981; --hpBack:#1f2937;
  --accent:#7c3aed;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--stroke)}
header .muted{color:var(--muted);margin-left:8px}
header button{background:#26325a;color:#fff;border:1px solid #31406e;border-radius:8px;padding:6px 10px;cursor:pointer}
header button:hover{filter:brightness(1.05)}
main{max-width:1000px;margin:14px auto;padding:12px;background:var(--panel);border:1px solid var(--stroke);border-radius:12px}
#game{display:block;width:100%;height:auto;border-radius:10px;border:1px solid var(--stroke);background:#0a1630;image-rendering:pixelated;touch-action:manipulation}
.help{margin:.6rem 0 0;color:#a1a1aa}
.help .coin{color:var(--coin);font-weight:700}
.help .potion{color:#a78bfa;font-weight:700}
#status{margin-top:8px;color:var(--muted)}
.fab{position:fixed;bottom:14px;width:56px;height:56px;border-radius:50%;border:1px solid #31406e;background:var(--accent);color:#fff;font-size:24px;line-height:56px;text-align:center;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.35);z-index:20}
.fab:active{transform:scale(0.98)}
@media (hover:hover){ .fab:hover{ filter:brightness(1.05) } }
#btnUsePotion{ right:14px }   /* üçµ */
#btnAttack{ right:82px }      /* üó°Ô∏è */
#atkCdCanvas{ position:fixed; right:82px; bottom:14px; width:56px; height:56px; z-index:21; pointer-events:none }
.quest{position:fixed;top:16px;right:16px;width:280px;background:#0f172a;border:1px solid #1f2a44;border-radius:10px;box-shadow:0 12px 28px rgba(0,0,0,.35);z-index:30}
.hidden{display:none}
.q-header{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-bottom:1px solid #1f2a44;font-weight:600}
.q-close{width:28px;height:28px;border-radius:6px;border:1px solid #31406e;background:#26325a;color:#fff;font-size:16px;cursor:pointer}
.q-body{padding:10px}
.q-title{font-weight:700;margin-bottom:6px}
.q-desc{color:#c7cad1;margin-bottom:8px}
.q-row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
.progress{width:100%;height:10px;background:#0b1224;border:1px solid #1f2a44;border-radius:6px;overflow:hidden}
.progress>div{height:100%;background:var(--accent);width:0%}
.q-reward{color:#d1fae5;margin-top:6px;font-size:13px}
.q-claim{width:100%;margin-top:10px;padding:8px 10px;border:1px solid #31406e;background:#2563eb;color:#fff;border-radius:8px;cursor:pointer}
.q-claim:disabled{background:#1f2a44;color:#9aa0ad;cursor:not-allowed}
</style>
</head>
<body>
<header>
  <div class="left"><strong>Drakoria</strong> <span class="muted">core</span></div>
  <div class="right">
    <button id="btnQuest">Quest</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnReset">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="960" height="576" aria-label="Gioco"></canvas>
  <p class="help">
    Clicca per muoverti ‚Ä¢ <b>üó°Ô∏è</b> o <b>SPAZIO</b> per attaccare ‚Ä¢ Clic sul nemico adiacente = attacco ‚Ä¢
    Raccogli <span class="coin">‚óè</span> e <span class="potion">üçµ</span> ‚Ä¢ Doppio tap = usa pozione
  </p>
  <div id="status"></div>
</main>

<button id="btnAttack" class="fab" aria-label="Attacca">üó°Ô∏è</button>
<canvas id="atkCdCanvas" width="56" height="56" aria-hidden="true"></canvas>
<button id="btnUsePotion" class="fab" aria-label="Usa pozione">üçµ</button>

<aside id="questPanel" class="quest hidden" aria-live="polite">
  <div class="q-header">
    <span>Quest</span>
    <button id="btnQuestClose" class="q-close" aria-label="Chiudi">√ó</button>
  </div>
  <div id="questBody" class="q-body"></div>
</aside>

<script>
/* ===== Drakoria ‚Äî BUILD D3-HUD1-root ===== */
(function(){
  const BUILD='D3-HUD1-root';
  const SAVE_KEY='barebones_save_v3', QUEST_KEY='barebones_quests_v1';

  const cv=document.getElementById('game'), ctx=cv.getContext('2d');
  const statusEl=document.getElementById('status');
  const btnReset=document.getElementById('btnReset'), btnSave=document.getElementById('btnSave'), btnLoad=document.getElementById('btnLoad');
  const btnUsePotion=document.getElementById('btnUsePotion'), btnAttack=document.getElementById('btnAttack');
  const atkCdCanvas=document.getElementById('atkCdCanvas'), atkCdCtx=atkCdCanvas.getContext('2d');
  const questPanel=document.getElementById('questPanel'), questBody=document.getElementById('questBody');
  const btnQuest=document.getElementById('btnQuest'), btnQuestClose=document.getElementById('btnQuestClose');

  const COLS=15, ROWS=9, TILE=64;
  const map=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  function genBlocks(){ for(let i=0;i<22;i++){ const x=(Math.random()*COLS|0), y=(Math.random()*ROWS|0); if((x===1&&y===1)||(x===COLS-2&&y===ROWS-2)) continue; map[y][x]=1; } }
  genBlocks();

  const player={x:1,y:1,hp:100,maxHp:100,coins:0,pots:0,atkMin:6,atkMax:12,lastAtk:0,atkCd:400,lvl:1,exp:0};

  const enemies=[]; function spawnMelee(x,y){return{type:'melee',x,y,hp:60,maxHp:60,tick:0,mode:'patrol',lastHit:0,hitCd:800,atkMin:5,atkMax:9,moveTick:0,chaseEvery:2,patrolEvery:8}}
  function spawnRanged(x,y){return{type:'ranged',x,y,hp:40,maxHp:40,tick:0,mode:'patrol',atkCd:1200,lastShot:0,rangeMin:3,rangeMax:8,kiteEvery:2,moveTick:0,patrolEvery:10,pokeCd:700,lastPoke:0}}
  const coins=[], potions=[], projectiles=[];
  function randEmpty(){ for(let k=0;k<800;k++){ const x=(Math.random()*COLS|0), y=(Math.random()*ROWS|0);
    const occ=(x===player.x&&y===player.y)||enemies.some(e=>e.x===x&&e.y===y)||coins.some(c=>c.x===x&&c.y===y)||potions.some(p=>p.x===x&&p.y===y);
    if(map[y][x]===0 && !occ) return {x,y}; } return {x:2,y:2}; }
  for(let i=0;i<6;i++) coins.push(randEmpty());
  for(let i=0;i<2;i++) potions.push(randEmpty());
  enemies.push(spawnMelee(COLS-2, ROWS-2)); { const s=randEmpty(); enemies.push(spawnRanged(s.x,s.y)); }

  const inside=(x,y)=>x>=0&&y>=0&&x<COLS&&y<ROWS, walkable=(x,y)=>inside(x,y)&&map[y][x]===0;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), manhattan=(a,b)=>Math.abs(a.x-b.x)+Math.abs(a.y-b.y), chebyshev=(a,b)=>Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y));
  const rndInt=(a,b)=>a+(Math.random()*(b-a+1)|0), getVar=n=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();

  const MAX_LVL=99, XP_COIN=2, XP_KILL_MELEE=20, XP_KILL_RANGED=25;
  const xpNeeded=l=>Math.floor(50*Math.pow(l,1.5));
  function gainXP(n){ if(player.lvl>=MAX_LVL) return; player.exp+=n; while(player.lvl<MAX_LVL && player.exp>=xpNeeded(player.lvl)){ player.exp-=xpNeeded(player.lvl); levelUp(); } }
  function levelUp(){ player.lvl=Math.min(MAX_LVL,player.lvl+1); player.maxHp+=10; player.hp=player.maxHp; player.atkMin++; player.atkMax++; player.atkCd=Math.max(200,player.atkCd-20); flashScreen('#22c55e'); }

  const quests=[{id:'q1',title:'Raccogli 10 monete',desc:'Trova e raccogli 10 monete.',type:'collect',target:'coins',needed:10,progress:0,status:'active',reward:{xp:50,pots:1}},
                {id:'q2',title:'Sconfiggi 3 nemici',desc:'Elimina qualsiasi nemico.',type:'kill',target:'any',needed:3,progress:0,status:'locked',reward:{xp:80,coins:3}}];
  let currentQuest=0;
  function renderQuest(){
    const q=quests[currentQuest]; if(!q){ questBody.innerHTML='<div class="q-title">Nessuna quest</div>'; return; }
    const ratio=q.needed?Math.floor(100*(q.progress/q.needed)):100, rw=q.reward||{}, dis=q.status!=='completed';
    questBody.innerHTML=`
      <div class="q-title">${q.title}</div>
      <div class="q-desc">${q.desc}</div>
      <div class="q-row"><div class="progress"><div style="width:${ratio}%"></div></div><div style="margin-left:8px">${q.progress}/${q.needed}</div></div>
      <div class="q-reward">Ricompensa: ${rw.xp?`+${rw.xp} XP `:''}${rw.coins?`¬∑ +${rw.coins} monete `:''}${rw.pots?`¬∑ +${rw.pots} pozione/i`:''}</div>
      <button id="btnClaim" class="q-claim" ${dis?'disabled':''}>Riscatta</button>`;
    const btn=document.getElementById('btnClaim'); if(btn) btn.onclick=claimQuest;
  }
  function questAdd(k,amt){ const q=quests[currentQuest]; if(!q||q.status!=='active') return;
    if(q.type==='collect'&&k==='coin') q.progress=Math.min(q.needed,(q.progress+(amt||1)));
    if(q.type==='kill'&&k.startsWith('kill_')) q.progress=Math.min(q.needed,(q.progress+(amt||1)));
    if(q.progress>=q.needed){ q.status='completed'; toast('Quest completata! Riscatta.'); } renderQuest();
  }
  function claimQuest(){ const q=quests[currentQuest]; if(!q||q.status!=='completed') return;
    const rw=q.reward||{}; if(rw.xp) gainXP(rw.xp); if(rw.coins) player.coins+=rw.coins; if(rw.pots) player.pots+=rw.pots;
    q.status='claimed'; if(currentQuest+1<quests.length){ currentQuest++; if(quests[currentQuest].status==='locked') quests[currentQuest].status='active'; toast('Nuova quest disponibile!'); } else toast('Tutte le quest completate.');
    renderQuest();
  }
  btnQuest.onclick=()=>questPanel.classList.toggle('hidden');
  btnQuestClose.onclick=()=>questPanel.classList.add('hidden');

  function bfs(sx,sy,tx,ty){
    if(!walkable(tx,ty)) return null;
    const q=[{x:sx,y:sy}], prev=new Map(), seen=new Set([sx+','+sy]), dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const c=q.shift();
      if(c.x===tx&&c.y===ty){ const path=[]; let k=tx+','+ty; while(prev.has(k)){ const p=prev.get(k), s=k.split(','); path.push({x:+s[0],y:+s[1]}); k=p.x+','+p.y; } return path.reverse(); }
      for(let i=0;i<4;i++){ const nx=c.x+dirs[i][0], ny=c.y+dirs[i][1], kk=nx+','+ny; if(!walkable(nx,ny)||seen.has(kk)) continue; seen.add(kk); prev.set(kk,c); q.push({x:nx,y:ny}); }
    }
    return null;
  }

  let pathQueue=[], lastTapTs=0;
  function canvasToTile(ev){ const r=cv.getBoundingClientRect(); const cx=(ev.clientX??ev.touches?.[0]?.clientX), cy=(ev.clientY??ev.touches?.[0]?.clientY);
    const sx=(cx-r.left)*(cv.width/r.width), sy=(cy-r.top)*(cv.height/r.height);
    return {sx,sy,tx:clamp((sx/TILE)|0,0,COLS-1), ty:clamp((sy/TILE)|0,0,ROWS-1)};
  }
  function enemyRect(e){ const x=e.x*TILE+TILE/2-16, y=e.y*TILE+TILE/2-22; return {x,y,w:32,h:36}; }
  function inRect(px,py,r){ return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h; }

  cv.addEventListener('click',ev=>{
    const m=canvasToTile(ev), now=performance.now(), cdReady=(now-player.lastAtk)>=player.atkCd;
    const adj=enemies.find(e=>chebyshev(player,e)===1 && inRect(m.sx,m.sy,enemyRect(e)));
    if(adj && cdReady){ attackEnemy(adj); return; }
    if(cdReady){ const onTile=enemies.find(e=>chebyshev(player,e)===1 && e.x===m.tx && e.y===m.ty); if(onTile){ attackEnemy(onTile); return; } }
    const p=bfs(player.x,player.y,m.tx,m.ty); if(p&&p.length) pathQueue=p;
  });
  cv.addEventListener('pointerdown',()=>{
    const now=performance.now();
    if(now-lastTapTs<=300){ usePotion(); lastTapTs=0; } else lastTapTs=now;
  });
  function tryAttackAdjacent(){ const now=performance.now(); if(now-player.lastAtk<player.atkCd) return false; const adj=enemies.find(en=>chebyshev(player,en)===1); if(adj){ attackEnemy(adj); return true; } return false; }
  document.getElementById('btnAttack').addEventListener('click', tryAttackAdjacent);
  document.getElementById('btnAttack').addEventListener('touchend', e=>{e.preventDefault();tryAttackAdjacent();},{passive:false});
  window.addEventListener('keydown',e=>{ if(e.code==='Space'||e.key===' ') tryAttackAdjacent(); if(e.key==='e'||e.key==='E') usePotion(); });
  document.getElementById('btnUsePotion').onclick=usePotion;
  document.getElementById('btnUsePotion').addEventListener('touchend',e=>{e.preventDefault();usePotion();},{passive:false});

  const dmgTexts=[]; function addDmgText(tx,ty,txt,color){ const px=tx*TILE+TILE/2, py=ty*TILE+TILE/2-28; dmgTexts.push({x:px,y:py,txt,color,ttl:700,vy:-0.04}); }
  function attackEnemy(t){ const now=performance.now(); player.lastAtk=now; const dmg=rndInt(player.atkMin,player.atkMax); t.hp=Math.max(0,t.hp-dmg); addDmgText(t.x,t.y,'-'+dmg,'#ffd166'); flashCircle(t.x,t.y,'#ff0000',.25,26);
    if(t.hp===0){ if(Math.random()<0.7) coins.push({x:t.x,y:t.y}); else potions.push({x:t.x,y:t.y}); questAdd('kill_any',1); gainXP(t.type==='ranged'?XP_KILL_RANGED:XP_KILL_MELEE);
      enemies.splice(enemies.indexOf(t),1); const s=randEmpty(); enemies.push(t.type==='ranged'?spawnRanged(s.x,s.y):spawnMelee(s.x,s.y)); }
    draw();
  }
  function hasLoS(ax,ay,bx,by){ if(ax===bx){ const st=ay<by?1:-1; for(let y=ay+st;y!==by;y+=st){ if(map[y][ax]===1) return false; } return true; }
    if(ay===by){ const st=ax<bx?1:-1; for(let x=ax+st;x!==bx;x+=st){ if(map[ay][x]===1) return false; } return true; } return false; }
  function enemiesAI(){
    for(const e of enemies){
      if(e.type==='melee'){
        const dist=manhattan(e,player); if(dist<=6) e.mode='chase'; else if(dist>=10) e.mode='patrol'; if(chebyshev(player,e)===1) continue;
        if(e.mode==='chase'){ e.moveTick=(e.moveTick+1)%e.chaseEvery; if(e.moveTick!==0) continue;
          const opts=[[1,0],[-1,0],[0,1],[0,-1]].map(d=>({x:e.x+d[0],y:e.y+d[1]})).filter(p=>walkable(p.x,p.y)&&!(p.x===player.x&&p.y===player.y));
          opts.sort((a,b)=>manhattan(a,player)-manhattan(b,player)); const best=opts[0]; if(best){ e.x=best.x; e.y=best.y; }
        } else { e.tick=(e.tick+1)%e.patrolEvery; if(e.tick===0){ const dirs=[[1,0],[-1,0],[0,1],[0,-1],[0,0]]; const d=dirs[(Math.random()*dirs.length)|0]; const nx=e.x+d[0], ny=e.y+d[1]; if(walkable(nx,ny)&&!(nx===player.x&&ny===player.y)){ e.x=nx; e.y=ny; } } }
      } else {
        const dist=manhattan(e,player), adj=chebyshev(e,player)===1;
        if(adj){ const now=performance.now(); if(now-e.lastPoke>=e.pokeCd){ e.lastPoke=now; const dmg=rndInt(5,9); player.hp=Math.max(0,player.hp-dmg); addDmgText(player.x,player.y,'-'+dmg,'#ff6b6b'); flashCircle(player.x,player.y,'#ff0000',.25,26); if(player.hp===0) gameOver(); } continue; }
        const inRange=dist>=e.rangeMin && dist<=e.rangeMax && hasLoS(e.x,e.y,player.x,player.y);
        if(inRange){ const now=performance.now(); if(now-e.lastShot>=e.atkCd){ e.lastShot=now; let dx=0,dy=0; if(e.x===player.x) dy=player.y>e.y?1:-1; else if(e.y===player.y) dx=player.x>e.x?1:-1; if(dx||dy) projectiles.push({x:e.x,y:e.y,dx,dy,spdTick:0,owner:'ranged',dmg:rndInt(6,10)}); }
          if(dist<e.rangeMin){ e.moveTick=(e.moveTick+1)%e.kiteEvery; if(e.moveTick===0){ const opts=[[1,0],[-1,0],[0,1],[0,-1],[0,0]].map(d=>({x:e.x+d[0],y:e.y+d[1]})).filter(p=>walkable(p.x,p.y)&&!(p.x===player.x&&p.y===player.y)); opts.sort((a,b)=>manhattan(b,player)-manhattan(a,player)); const best=opts[0]; if(best){ e.x=best.x; e.y=best.y; } } }
        } else { e.tick=(e.tick+1)%e.patrolEvery; if(e.tick===0){ const dx=Math.sign(player.x-e.x), dy=Math.sign(player.y-e.y); const opts=[]; if(dx) opts.push({x:e.x+dx,y:e.y}); if(dy) opts.push({x:e.x,y:e.y+dy}); opts.push({x:e.x,y:e.y}); const mv=opts.find(p=>walkable(p.x,p.y)&&!(p.x===player.x&&p.y===player.y)); if(mv){ e.x=mv.x; e.y=mv.y; } } }
      }
    }
  }
  function updateProjectiles(){
    for(let i=projectiles.length-1;i>=0;i--){
      const pr=projectiles[i]; pr.spdTick=(pr.spdTick+1)%2; if(pr.spdTick!==0) continue;
      const nx=pr.x+pr.dx, ny=pr.y+pr.dy;
      if(!inside(nx,ny)||map[ny][nx]===1){ projectiles.splice(i,1); continue; }
      if(nx===player.x&&ny===player.y){
        const dmg=pr.dmg; player.hp=Math.max(0,player.hp-dmg); addDmgText(player.x,player.y,'-'+dmg,'#ff6b6b'); flashCircle(player.x,player.y,'#ff0000',.25,26); projectiles.splice(i,1); if(player.hp===0) gameOver(); continue;
      }
      pr.x=nx; pr.y=ny;
    }
  }
  function handleInteractions(){
    if(pathQueue.length){ const next=pathQueue.shift(); if(walkable(next.x,next.y) && !enemies.some(e=>e.x===next.x&&e.y===next.y)){ player.x=next.x; player.y=next.y; } else pathQueue=[]; }
    for(let i=coins.length-1;i>=0;i--){ if(coins[i].x===player.x&&coins[i].y===player.y){ coins.splice(i,1); player.coins++; gainXP(XP_COIN); questAdd('coin',1); } }
    for(let i=potions.length-1;i>=0;i--){ if(potions[i].x===player.x&&potions[i].y===player.y){ potions.splice(i,1); player.pots++; } }
    const now=performance.now();
    for(const e of enemies){ if(e.type!=='melee') continue; const touching=chebyshev(player,e)===0, adjacent=chebyshev(player,e)===1;
      if((touching||adjacent) && (now-e.lastHit)>=e.hitCd){ e.lastHit=now; const dmg=rndInt(e.atkMin,e.atkMax); player.hp=Math.max(0,player.hp-dmg); addDmgText(player.x,player.y,'-'+dmg,'#ff6b6b'); flashCircle(player.x,player.y,'#ff0000',.25,26); if(player.hp===0) gameOver(); } }
  }
  function usePotion(){ if(player.pots<=0||player.hp>=player.maxHp) return; player.pots--; player.hp=Math.min(player.maxHp,player.hp+35); flashScreen('#8b5cf6'); draw(); }

  function saveCore(){return{build:BUILD,map,player,enemies,coins,potions}}
  function loadCore(d){ if(d?.map?.length===ROWS){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) map[y][x]=d.map[y][x]|0; } if(d?.player) Object.assign(player,d.player);
    enemies.length=0; (d?.enemies||[]).forEach(e=>enemies.push(e.type==='ranged'?Object.assign(spawnRanged(e.x|0,e.y|0),e):Object.assign(spawnMelee(e.x|0,e.y|0),e)));
    coins.length=0; (d?.coins||[]).forEach(c=>coins.push({x:c.x|0,y:c.y|0})); potions.length=0; (d?.potions||[]).forEach(p=>potions.push({x:p.x|0,y:p.y|0})); projectiles.length=0; }
  function saveQuests(){return{currentQuest,quests}}
  function loadQuests(qd){ if(!qd) return; currentQuest=Math.min(qd.currentQuest|0,quests.length-1);
    if(qd.quests?.length){ for(let i=0;i<quests.length&&i<qd.quests.length;i++){ quests[i].progress=qd.quests[i].progress|0; quests[i].status=qd.quests[i].status||quests[i].status; } } renderQuest(); }
  function saveAll(){ try{ localStorage.setItem(SAVE_KEY,JSON.stringify(saveCore())); localStorage.setItem(QUEST_KEY,JSON.stringify(saveQuests())); toast('Salvato.'); }catch(e){ alert('Errore salvataggio'); } }
  function loadAll(){ try{ const core=localStorage.getItem(SAVE_KEY); if(!core) return alert('Nessun salvataggio.'); loadCore(JSON.parse(core)); const qd=localStorage.getItem(QUEST_KEY); if(qd) loadQuests(JSON.parse(qd)); draw(); toast('Caricato.'); }catch(e){ alert('Errore caricamento'); } }

  function softRespawn(){ player.hp=player.maxHp; player.x=1; player.y=1; projectiles.length=0; for(const e of enemies){ const s=randEmpty(); e.x=s.x; e.y=s.y; if(e.type==='ranged'){e.lastShot=0;e.lastPoke=0;} if(e.type==='melee'){e.lastHit=0;} } pathQueue.length=0; draw(); }
  function hardReset(){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) map[y][x]=0; genBlocks();
    Object.assign(player,{x:1,y:1,hp:100,maxHp:100,coins:0,pots:0,lastAtk:0,atkMin:6,atkMax:12,atkCd:400,lvl:1,exp:0});
    enemies.length=0; enemies.push(spawnMelee(COLS-2,ROWS-2)); { const s=randEmpty(); enemies.push(spawnRanged(s.x,s.y)); }
    coins.length=0; for(let i=0;i<6;i++) coins.push(randEmpty()); potions.length=0; for(let i=0;i<2;i++) potions.push(randEmpty());
    projectiles.length=0; pathQueue.length=0; quests.forEach((q,i)=>{ q.progress=0; q.status=(i===0)?'active':'locked'; }); currentQuest=0; draw(); renderQuest(); }
  function gameOver(){ alert('Sei stato sconfitto! Respawn senza perdita di livello/EXP.'); softRespawn(); }

  function step(){ enemiesAI(); updateProjectiles(); handleInteractions(); updateDmgTexts(); draw(); drawAtkCooldown(); }
  draw(); setInterval(step,120);

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      ctx.fillStyle=(map[y][x]===1)?getVar('--block'):((x+y)%2===0?getVar('--tileA'):getVar('--tileB'));
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
    ctx.fillStyle=getVar('--coin'); for(const c of coins){ const cx=c.x*TILE+TILE/2, cy=c.y*TILE+TILE/2; ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fill(); }
    for(const p of potions){ const x=p.x*TILE,y=p.y*TILE; ctx.fillStyle='#8b5cf6'; ctx.fillRect(x+TILE/2-8,y+TILE/2-14,16,20); ctx.fillStyle='#a78bfa'; ctx.fillRect(x+TILE/2-5,y+TILE/2-20,10,6); ctx.fillStyle='#6d28d9'; ctx.fillRect(x+TILE/2-6,y+TILE/2-24,12,4); ctx.fillStyle='#0006'; ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,12,4,0,0,Math.PI*2); ctx.fill(); }
    for(const e of enemies){ drawActor(e.x,e.y, e.type==='ranged' ? '#a855f7' : getVar('--enemy')); drawEnemyHpBar(e.x,e.y,e.hp,e.maxHp); }
    drawActor(player.x,player.y,getVar('--player')); drawHpBar(player.x,player.y,player.hp,player.maxHp);
    for(const pr of projectiles){ const x=pr.x*TILE+TILE/2, y=pr.y*TILE+TILE/2; ctx.fillStyle='#f87171'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill(); }
    drawDmgTexts();
    drawXpBar();
    ctx.fillStyle='#ffffffcc'; ctx.font='bold 14px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText('BUILD '+BUILD, 8, 32);
    updateStatus();
  }
  function updateStatus(){
    const now=performance.now(), cdRemain=Math.max(0,player.atkCd-(now-player.lastAtk)), cdPct=Math.round(100*cdRemain/player.atkCd);
    const nearest=enemies.reduce((m,e)=>Math.min(m,manhattan(e,player)),999);
    const need=player.lvl<MAX_LVL?xpNeeded(player.lvl):0, xpPct=player.lvl<MAX_LVL?Math.floor(100*player.exp/need):100;
    statusEl.textContent=`build: ${BUILD} | LV ${player.lvl} | XP ${xpPct}% | CD ${cdRemain.toFixed(0)}ms (${cdPct}%) | enemies: ${enemies.length} (nearest=${nearest}) | HP: ${player.hp}/${player.maxHp} | coins: ${player.coins} | pots: ${player.pots}`;
  }
  function drawActor(tx,ty,color){ const x=tx*TILE, y=ty*TILE; ctx.fillStyle=getVar('--shadow'); ctx.beginPath(); ctx.ellipse(x+TILE/2,y+TILE-12,18,6,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle=color; ctx.fillRect(x+TILE/2-16,y+TILE/2-22,32,36); }
  function drawHpBar(tx,ty,hp,maxHp){ const x=tx*TILE,y=ty*TILE,w=40,h=6,px=x+TILE/2-w/2,py=y+TILE/2-32, r=Math.max(0,Math.min(1,hp/maxHp)); ctx.fillStyle=getVar('--hpBack'); ctx.fillRect(px,py,w,h); ctx.fillStyle=getVar('--hp'); ctx.fillRect(px,py,w*r,h); ctx.strokeStyle='#0008'; ctx.strokeRect(px,py,w,h); }
  function drawEnemyHpBar(tx,ty,hp,maxHp){ const ratio=Math.max(0,Math.min(1,hp/maxHp)); let col='#10b981'; if(ratio<0.66) col='#f59e0b'; if(ratio<0.33) col='#ef4444'; const x=tx*TILE,y=ty*TILE,w=40,h=6,px=x+TILE/2-w/2,py=y+TILE/2-32; ctx.fillStyle='#1f2937'; ctx.fillRect(px,py,w,h); ctx.fillStyle=col; ctx.fillRect(px,py,w*ratio,h); ctx.strokeStyle='#0008'; ctx.strokeRect(px,py,w,h); }
  function drawXpBar(){ const h=10,pad=6,x=pad,y=pad,w=cv.width-pad*2, need=player.lvl<MAX_LVL?xpNeeded(player.lvl):1, ratio=player.lvl<MAX_LVL?Math.max(0,Math.min(1,player.exp/need)):1; ctx.fillStyle='#0b1224aa'; ctx.fillRect(x,y,w,h); ctx.fillStyle='#7c3aed'; ctx.fillRect(x,y,w*ratio,h); ctx.strokeStyle='#1f2a44'; ctx.strokeRect(x,y,w,h); ctx.fillStyle='#e5e7eb'; ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText(`LV ${player.lvl}${player.lvl<MAX_LVL?` ‚Äî ${Math.floor(ratio*100)}%`:''}`, x, y+h+2); }
  function flashScreen(color){ ctx.save(); ctx.globalAlpha=.20; ctx.fillStyle=color; ctx.fillRect(0,0,cv.width,cv.height); ctx.restore(); }
  function flashCircle(tx,ty,color,alpha,r){ const x=tx*TILE+TILE/2,y=ty*TILE+TILE/2; ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  const dmgTexts=[]; function updateDmgTexts(){ const dt=120; for(let i=dmgTexts.length-1;i>=0;i--){ const d=dmgTexts[i]; d.ttl-=dt; d.y+=d.vy*dt; if(d.ttl<=0) dmgTexts.splice(i,1); } }
  function drawDmgTexts(){ for(const d of dmgTexts){ const a=Math.max(0,Math.min(1,d.ttl/700)); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=d.color; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(d.txt, d.x, d.y); ctx.restore(); } }
  function drawAtkCooldown(){ const now=performance.now(), remain=Math.max(0,player.atkCd-(now-player.lastAtk)), ratio=1-(remain/player.atkCd); const c=atkCdCtx, cx=28, cy=28, r=25; c.clearRect(0,0,56,56); c.globalAlpha=0.15; c.fillStyle='#000'; c.beginPath(); c.arc(cx,cy,r,0,Math.PI*2); c.fill(); c.globalAlpha=0.85; c.strokeStyle= remain>0 ? '#94a3b8' : '#22c55e'; c.lineWidth=4; c.beginPath(); c.arc(cx,cy,r-2,-Math.PI/2, -Math.PI/2 + ratio*2*Math.PI); c.stroke(); }
  btnReset.onclick=hardReset; btnSave.onclick=saveAll; btnLoad.onclick=loadAll;

  setInterval(step,120); draw(); drawAtkCooldown();

  function toast(msg){ statusEl.textContent='['+BUILD+'] '+msg; setTimeout(updateStatus,900); }
})();
</script>
</body>
</html>
